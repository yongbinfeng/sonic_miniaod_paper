This section describes the computing setup of the CMS experiment, the software framework \CMSSW, and the Mini-AOD data production workflow.

\subsection{Introduction to CMS Computing}
\label{sec:implementation}

The LHC provides countercirculating beams of high energy protons, such that bunches of protons in these beams can interact with each other in the center of the CMS detector~\cite{CMS:2008xjf} every 25\unit{ns}. When protons from the countercirculating beams collide, a large variety of physical processes can occur, which then lead to the creation of either fundamental or composite particles. These particles, or their decay products, can then propagate into the CMS detector, which is designed to determine the type, energy, and momentum of each particle. Each bunch crossing where proton collisions occurs is referred to as an ``event'', in which hundreds of particles can be projected into the CMS detector. The detector itself comprises multiple layers including silicon pixels and strips, crystal calorimeters, sampling calorimeters, and muon spectrometers. Each component of the detector has active components that create electrical signals when particles interact with them, either from their charge or through interactions with the material's atomic electrons or nucleus. Each discrete signal can be called a hit.

\subsection{\CMSSW}
\label{sec:cmssw}
One purpose of the \CMSSW software stack is to extract high-level physics information for each event from these hits. In essence, physicists can use \CMSSW to determine which of the large number of possible physical processes occurred in a given event, be it something relatively rare, such as the creation of a Higgs boson, or something as common the scattering of gluons in colliding protons. CMSSW processes each event with a sequence of algorithms, converting hits from electrical signals to positional and energy measurements, linking these measurements into clusters~\cite{CMS:2020uim} and trajectories~\cite{CMS:2014pgm}, combining trajectories and clusters into single particle representations and jets corresponding to hadronic showers~\cite{CMS:2017yfk}. Additional algorithms in CMS can be run to determine quantities such as the total imbalance of energy across the axis defined by the proton beam line or tag jets as containing or being produced by rare particles.

The \CMSSW framework uses Intel Threading Building Blocks~\cite{tbb} to enable task-based multithreading. As explained in Ref.~\cite{Bocci:2020olh}, this multithreading implementation allows for asynchronous non-blocking calls to external resources, such as a GPU, via ``ExternalWork''. This setup optimizes CPU resource utilization by minimizing downtime; the CPU is allowed to continue executing algorithms that do not require a coprocessor or depend on the results of the coprocessor-dependent algorithm while waiting for the external call to return.

\subsection{Mini-AOD production}
\label{sec:miniaod_production}
CMSSW is used both in online and offline contexts within CMS. While the Level-1 trigger is hardware-based, the high-level trigger (HLT) is constructed from algorithms in CMSSW. CMSSW also contains the algorithms that are used to process the raw data after it has been stored, deriving the higher-level information useful to physicists. The centralized offline CMS data processing flow involves a few steps. The first creates an ``analysis object data'' (AOD) format derivation of every raw event. Then the second creates a slimmed, higher-level ``Mini-AOD''derivation~\cite{Petrucciani:2015gjw}. Finally the third creates a further slimmed ``NANOAOD" format that contains only top-level information used for physics analyses~\cite{Rizzi:2019rsi}. Because algorithms within \CMSSW are occasionally modified, the raw data is reprocessed regularly. The AOD derivation step is performed on a yearly base and the subsequent Mini-AOD step is typically performed roughly a few times per year .

Mini-AOD files are designed to be relatively small and accessible, providing the high-level physics information needed for most analyses. They are derived from the AOD data format, reducing the size per event by a factor of 10. Mini-AOD processing involves a wide variety of algorithms that propagate, skim, and reanalyze the AOD input objects. 